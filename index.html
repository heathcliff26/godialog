
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>godialog: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/heathcliff26/godialog/dialog.go (100.0%)</option>
				
				<option value="file1">github.com/heathcliff26/godialog/dialog_linux.go (13.2%)</option>
				
				<option value="file2">github.com/heathcliff26/godialog/fallback/fyne/dialog.go (59.4%)</option>
				
				<option value="file3">github.com/heathcliff26/godialog/fallback/fyne/utils.go (100.0%)</option>
				
				<option value="file4">github.com/heathcliff26/godialog/filter.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package godialog

// Ensure fileDialog implements the FileDialog interface.
var _ FileDialog = &amp;fileDialog{}

type DialogCallback func(string, error)

type FallbackDialog interface {
        // Shows the open file dialog and calls the callback asynchronously.
        Open(title string, initialDirectory string, filters FileFilters, cb DialogCallback)
        // Shows the save file dialog and calls the callback asynchronously.
        Save(title string, initialDirectory string, filters FileFilters, cb DialogCallback)
}

// OS native file dialog. Allows to define a fallback implementation in case it does not work.
// callbacks are always called asynchronously.
type FileDialog interface {
        // Return the current file filters (nil if no filters are set).
        Filters() FileFilters
        // Add a new filter to the list of filters.
        AddFilter(filter FileFilter)
        // Set the file filters.
        SetFilters(filters FileFilters)
        // The current fallback dialog.
        // Returns nil if no fallback is set.
        Fallback() FallbackDialog
        // Set the fallback dialog in case the native dialog does not work.
        SetFallback(fallback FallbackDialog)
        // Set the initial directory for the file dialog.
        SetInitialDirectory(dir string)
        // Get the initial directory for the file dialog.
        InitialDirectory() string

        // Show a file open dialog in a new window and return path.
        Open(title string, cb DialogCallback)
        // Show a file save dialog in a new window and return path.
        Save(title string, cb DialogCallback)
}

// OS native file dialog. Allows to define a fallback implementation in case it does not work.
// File dialogs are always opened asynchronously.
type fileDialog struct {
        // The directory that the file dialog should open in.
        initialDirectory string
        filters          FileFilters
        fallback         FallbackDialog
}

// Create a new file dialog.
func NewFileDialog() FileDialog <span class="cov10" title="4">{
        return &amp;fileDialog{}
}</span>

// Return the current file filters (nil if no filters are set).
func (fd *fileDialog) Filters() FileFilters <span class="cov5" title="2">{
        return fd.filters
}</span>

// Add a new filter to the list of filters.
func (fd *fileDialog) AddFilter(filter FileFilter) <span class="cov1" title="1">{
        fd.filters = append(fd.filters, filter)
}</span>

// Set the file filters.
func (fd *fileDialog) SetFilters(filters FileFilters) <span class="cov1" title="1">{
        fd.filters = filters
}</span>

// The current fallback dialog.
// Returns nil if no fallback is set.
func (fd *fileDialog) Fallback() FallbackDialog <span class="cov1" title="1">{
        return fd.fallback
}</span>

// Set the fallback dialog in case the native dialog does not work.
func (fd *fileDialog) SetFallback(fallback FallbackDialog) <span class="cov1" title="1">{
        fd.fallback = fallback
}</span>

// Set the initial directory for the file dialog.
func (fd *fileDialog) SetInitialDirectory(dir string) <span class="cov1" title="1">{
        fd.initialDirectory = dir
}</span>

// Get the initial directory for the file dialog.
func (fd *fileDialog) InitialDirectory() string <span class="cov1" title="1">{
        return fd.initialDirectory
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">//go:build linux

package godialog

import (
        "fmt"
        "log/slog"
        "strings"

        "github.com/godbus/dbus/v5"
)

const (
        DBusObjectName = "org.freedesktop.portal.Desktop"
        DBusObjectPath = "/org/freedesktop/portal/desktop"

        DBusFileChooserBase     = "org.freedesktop.portal.FileChooser"
        DBusFileChooserOpenFile = ".OpenFile"
        DBusFileChooserSaveFile = ".SaveFile"
)

type freedesktopFilterRule struct {
        Type    uint32
        Pattern string
}

// Filter specifies a filter containing various rules for allowed files.
type freedesktopFilter struct {
        Name  string
        Rules []freedesktopFilterRule
}

// Show a file open dialog in a new window and return path.
func (fd *fileDialog) Open(title string, cb DialogCallback) <span class="cov0" title="0">{
        err := fd.dbusFileChooser(DBusFileChooserOpenFile, title)
        if err != nil </span><span class="cov0" title="0">{
                if fd.fallback != nil </span><span class="cov0" title="0">{
                        slog.Info("Failed to open linux native file dialog, using fallback", "error", err)
                        fd.fallback.Open(title, fd.InitialDirectory(), fd.filters, cb)
                }</span> else<span class="cov0" title="0"> {
                        go cb("", fmt.Errorf("cannot open file dialog: %w", err))
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">go cb(dbusWaitForResponse())</span>
}

// Show a file save dialog in a new window and return path.
func (fd *fileDialog) Save(title string, cb DialogCallback) <span class="cov0" title="0">{
        err := fd.dbusFileChooser(DBusFileChooserSaveFile, title)
        if err != nil </span><span class="cov0" title="0">{
                if fd.fallback != nil </span><span class="cov0" title="0">{
                        slog.Info("Failed to open linux native file dialog, using fallback", "error", err)
                        fd.fallback.Save(title, fd.InitialDirectory(), fd.filters, cb)
                }</span> else<span class="cov0" title="0"> {
                        go cb("", fmt.Errorf("cannot open file dialog: %w", err))
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">go cb(dbusWaitForResponse())</span>
}

// Call freedesktop via dbus to show a file chooser dialog.
func (fd *fileDialog) dbusFileChooser(method string, title string) error <span class="cov0" title="0">{
        freedesktopFilters := convertFiltersToFreedesktopFilter(fd.filters)

        currentFolder := make([]byte, len(fd.InitialDirectory())+1)
        copy(currentFolder, fd.InitialDirectory())

        options := map[string]dbus.Variant{
                "modal":          dbus.MakeVariant(true),
                "current_folder": dbus.MakeVariant(currentFolder),
                "filters":        dbus.MakeVariant(freedesktopFilters),
        }

        conn, err := dbus.SessionBus() // shared connection, don't close
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to connect to session bus: %w", err)
        }</span>

        <span class="cov0" title="0">obj := conn.Object(DBusObjectName, DBusObjectPath)
        err = obj.Call(DBusFileChooserBase+method, 0, "", title, options).Err
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to call %s on dbus: %w", method, err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func convertFiltersToFreedesktopFilter(filters FileFilters) []freedesktopFilter <span class="cov1" title="1">{
        var result []freedesktopFilter
        for _, filter := range filters </span><span class="cov10" title="4">{
                var filterRules []freedesktopFilterRule
                for _, rule := range filter.Extensions </span><span class="cov10" title="4">{
                        filterRules = append(filterRules, freedesktopFilterRule{Type: 0, Pattern: "*" + rule})
                }</span>
                <span class="cov10" title="4">result = append(result, freedesktopFilter{Name: filter.Description, Rules: filterRules})</span>
        }
        <span class="cov1" title="1">return result</span>
}

// Wait for the response from the file chooser dialog.
func dbusWaitForResponse() (string, error) <span class="cov0" title="0">{
        conn, err := dbus.SessionBus() // shared connection, don't close
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to connect to session bus: %w", err)
        }</span>

        <span class="cov0" title="0">err = conn.AddMatchSignal(
                dbus.WithMatchObjectPath(DBusObjectPath),
                dbus.WithMatchInterface("org.freedesktop.portal.Request"),
                dbus.WithMatchMember("Response"),
        )
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to subscribe to response signal: %w", err)
        }</span>
        <span class="cov0" title="0">c := make(chan *dbus.Signal)
        conn.Signal(c)

        res := &lt;-c
        if len(res.Body) &lt; 2 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("invalid response from dbus: %v", res.Body)
        }</span>
        <span class="cov0" title="0">if res.Body[0].(uint32) != 0 </span><span class="cov0" title="0">{
                // User cancelled the dialog
                return "", nil
        }</span>
        <span class="cov0" title="0">uris := res.Body[1].(map[string]dbus.Variant)["uris"].Value().([]string)
        if len(uris) == 0 </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        <span class="cov0" title="0">path, _ := strings.CutPrefix(uris[0], "file://")
        return path, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package fyne

import (
        "fmt"

        "fyne.io/fyne/v2"
        "fyne.io/fyne/v2/dialog"
        "fyne.io/fyne/v2/storage"
        "github.com/heathcliff26/godialog"
)

const (
        DefaultDialogHeight float32 = 800
        DefaultDialogWidth  float32 = 600
)

// Ensure FyneFallbackDialog implements godialog.FallbackDialog
var _ godialog.FallbackDialog = &amp;FyneFallbackDialog{}

// Opens a file dialog in a new fyne window for the given app.
type FyneFallbackDialog struct {
        App    fyne.App
        Height float32
        Width  float32
}

func NewFyneFallbackDialog(app fyne.App) *FyneFallbackDialog <span class="cov10" title="2">{
        return &amp;FyneFallbackDialog{
                App:    app,
                Height: DefaultDialogHeight,
                Width:  DefaultDialogWidth,
        }
}</span>

// Shows the open file dialog and calls the callback asynchronously.
func (f *FyneFallbackDialog) Open(title string, initialDirectory string, filters godialog.FileFilters, cb godialog.DialogCallback) <span class="cov1" title="1">{
        if f.App == nil </span><span class="cov1" title="1">{
                go cb("", fmt.Errorf("cannot open file dialog: fyne.App is nil"))
                return
        }</span>

        <span class="cov0" title="0">w := f.App.NewWindow(title)
        d := dialog.NewFileOpen(func(uri fyne.URIReadCloser, err error) </span><span class="cov0" title="0">{
                // Ensure this runs in a goroutine as we call fyne.DoAndWait in the callback
                go callCallback(cb, uri, err)
        }</span>, w)

        <span class="cov0" title="0">err := f.showFileDialog(initialDirectory, filters, d, w)
        if err != nil </span><span class="cov0" title="0">{
                go cb("", err)
        }</span>
}

// Shows the save file dialog and calls the callback asynchronously.
func (f *FyneFallbackDialog) Save(title string, initialDirectory string, filters godialog.FileFilters, cb godialog.DialogCallback) <span class="cov1" title="1">{
        if f.App == nil </span><span class="cov1" title="1">{
                go cb("", fmt.Errorf("cannot open file dialog: fyne.App is nil"))
                return
        }</span>

        <span class="cov0" title="0">w := f.App.NewWindow(title)
        d := dialog.NewFileSave(func(uri fyne.URIWriteCloser, err error) </span><span class="cov0" title="0">{
                // Ensure this runs in a goroutine as we call fyne.DoAndWait in the callback
                go callCallback(cb, uri, err)
        }</span>, w)

        <span class="cov0" title="0">err := f.showFileDialog(initialDirectory, filters, d, w)
        if err != nil </span><span class="cov0" title="0">{
                go cb("", err)
        }</span>
}

func (f *FyneFallbackDialog) showFileDialog(initialDirectory string, filters godialog.FileFilters, d *dialog.FileDialog, w fyne.Window) error <span class="cov10" title="2">{
        d.SetFilter(storage.NewExtensionFileFilter(filters.Extensions()))

        err := setDialogLocationToDir(initialDirectory, d)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov1" title="1">d.SetOnClosed(func() </span><span class="cov0" title="0">{
                w.Close()
        }</span>)

        <span class="cov1" title="1">w.Resize(fyne.NewSize(f.Height, f.Width))
        w.SetFixedSize(true)
        d.Resize(fyne.NewSize(f.Height, f.Width))
        fyne.Do(func() </span><span class="cov1" title="1">{
                w.Show()
                d.Show()
        }</span>)

        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package fyne

import (
        "fmt"

        "fyne.io/fyne/v2"
        "fyne.io/fyne/v2/dialog"
        "fyne.io/fyne/v2/storage"
        "github.com/heathcliff26/godialog"
)

// Set a file dialogs location to the given directory.
// When dir is empty, uses current directory.
// Returns error on failure.
func setDialogLocationToDir(dir string, d *dialog.FileDialog) error <span class="cov10" title="5">{
        uri, err := storage.ParseURI("file://" + dir)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to parse URI: %w", err)
        }</span>
        <span class="cov8" title="4">listURI, err := storage.ListerForURI(uri)
        if err != nil </span><span class="cov4" title="2">{
                return fmt.Errorf("failed to create lister for URI: %w", err)
        }</span>
        <span class="cov4" title="2">d.SetLocation(listURI)

        return nil</span>
}

type GenericURICloser interface {
        Close() error
        URI() fyne.URI
}

func callCallback(cb godialog.DialogCallback, uri GenericURICloser, err error) <span class="cov7" title="3">{
        if err != nil </span><span class="cov1" title="1">{
                cb("", err)
                return
        }</span>
        <span class="cov4" title="2">if uri == nil </span><span class="cov1" title="1">{
                cb("", nil)
                return
        }</span>
        <span class="cov1" title="1">defer uri.Close()

        path := uri.URI().Path()
        cb(path, nil)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package godialog

type FileFilter struct {
        // A short description of this filter.
        // Example: "Images (*.png, *.jpg)"
        Description string
        // A list of file extensions to filter.
        // Example: []string{".png", ".jpg"}
        Extensions []string
}

type FileFilters []FileFilter

// Returns a list of all file extensions from all filters.
func (ff FileFilters) Extensions() []string <span class="cov1" title="1">{
        var extensions []string
        for _, filter := range ff </span><span class="cov10" title="4">{
                extensions = append(extensions, filter.Extensions...)
        }</span>
        <span class="cov1" title="1">return extensions</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
